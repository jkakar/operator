#!/usr/bin/env ruby

require "yaml"
require "optparse"
require "thread"

REGISTRY = "docker.dev.pardot.com"
THREADS = 3

all = false
common = false
mirror = REGISTRY
parser = OptionParser.new { |opts|
  opts.banner = "Usage: pull [--all] image [image...]"

  opts.on("-a", "--all", "Pull all images") do
    all = true
  end
  opts.on("-c", "--common", "Pull commonly used images") do
    common = true
  end
  opts.on("-mMIRROR", "--mirror=MIRROR", "Uses the given mirror as an alias") do |m|
    mirror = m
  end
}
parser.parse!

if (!all && !common) && ARGV.length == 0
  puts parser.help
  abort
end

all_images = YAML.load_file(File.join(File.dirname(__FILE__), "..", "images.yml")).fetch("images")
images = \
  if all
    all_images.keys
  elsif common
    all_images.select { |image, attributes| attributes["common"] }.map { |image, _| image }
  else
    ARGV
  end

images.each do |image|
  unless all_images.key?(image)
    puts "error: #{image} not defined in images.yml"
    abort
  end
end

image_queue = Queue.new
images.each { |i| image_queue << i }

threads = THREADS.times.map { |t|
  Thread.new do
    until images.empty?
      begin
        image = image_queue.pop(true)

        pid = Process.spawn(
          File.join(File.dirname(__FILE__), "docker"),
          "pull",
          image.gsub(REGISTRY, mirror),
          close_others: true
        )
        Process.waitpid(pid)
        exit $?.exitstatus unless $?.success?

        pid = Process.spawn(
          File.join(File.dirname(__FILE__), "docker"),
          "tag",
          image.gsub(REGISTRY, mirror),
          image,
          close_others: true
        )
        Process.waitpid(pid)
        exit $?.exitstatus unless $?.success?
      rescue ThreadError
        break # queue is empty; we're done here
      end
    end
  end
}

threads.each(&:join)
