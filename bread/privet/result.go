package privet

import (
	"bufio"
	"encoding/xml"
	"fmt"
	"io"
	"regexp"
	"strings"
	"time"
)

type TestCaseResult struct {
	Name     string
	Duration time.Duration
}

type TestCaseResultSet struct {
	names   map[string]bool
	results []*TestCaseResult
}

func NewTestCaseResultSet() *TestCaseResultSet {
	return &TestCaseResultSet{
		names:   map[string]bool{},
		results: []*TestCaseResult{},
	}
}

func NewTestCaseResultSetWithResults(results []*TestCaseResult) *TestCaseResultSet {
	set := NewTestCaseResultSet()
	for _, result := range results {
		set.ConditionalAdd(result)
	}
	return set
}

// ConditionalAdd adds a result to the set if a result with the same name does not already exist in the set
func (s *TestCaseResultSet) ConditionalAdd(result *TestCaseResult) bool {
	if s.names[result.Name] {
		return false
	}

	s.results = append(s.results, result)
	s.names[result.Name] = true
	return true
}

func (s *TestCaseResultSet) Flattened() []*TestCaseResult {
	return s.results
}

func (s *TestCaseResultSet) Merge(other *TestCaseResultSet) {
	for _, result := range other.Flattened() {
		s.ConditionalAdd(result)
	}
}

type TestFileResult struct {
	Name        string
	Filename    string
	Fingerprint string
	Duration    time.Duration
	TestCases   *TestCaseResultSet
}

type TestRunResults map[string]*TestFileResult

// Merge merges test run tests. Because we might bust up individual files into
// smaller chunks of test cases, to get an accurate sense of duration and the
// number of test cases in each file, we must merge individual test cases batch
// together after parsing the results.
func (r TestRunResults) Merge(o TestRunResults) {
	for key, otherResult := range o {
		if result, ok := r[key]; ok {
			result.Duration += otherResult.Duration
			result.TestCases.Merge(otherResult.TestCases)
		} else {
			r[key] = otherResult
		}
	}
}

// ParseJunitResult parses a JUnit result file into a list of TestFileResult
// structs, describing the attributes of a previous test run.
func ParseJunitResult(r io.Reader) (TestRunResults, error) {
	results := TestRunResults{}

	decoder := xml.NewDecoder(r)
	var currentResult *TestFileResult
	for {
		token, err := decoder.Token()
		if err == io.EOF {
			break
		} else if err != nil {
			return nil, err
		}

		switch element := token.(type) {
		case xml.StartElement:
			if element.Name.Local == "testsuite" {
				attrMap := xmlAttributeListToMap(element.Attr)

				// If the <testcase> doesn't have a file
				// attribute, we're not interested in it. It's
				// either the outermost <testsuite> representing a
				// --group or it's an innermost <testsuite>
				// representing a group of test cases with data
				// sets
				if attrMap["name"] == "" || attrMap["file"] == "" {
					continue
				}

				currentResult = &TestFileResult{
					Name:      attrMap["name"],
					Filename:  attrMap["file"],
					TestCases: NewTestCaseResultSet(),
				}
				if timeValue, ok := attrMap["time"]; ok {
					currentResult.Duration, _ = time.ParseDuration(fmt.Sprintf("%ss", timeValue))
				}
				results[currentResult.Filename] = currentResult
			} else if element.Name.Local == "testcase" {
				attrMap := xmlAttributeListToMap(element.Attr)

				if attrMap["name"] == "" {
					continue
				} else if currentResult == nil {
					continue
				}

				testCaseResult := &TestCaseResult{
					Name: attrMap["name"],
				}
				if timeValue, ok := attrMap["time"]; ok {
					testCaseResult.Duration, _ = time.ParseDuration(fmt.Sprintf("%ss", timeValue))
				}
				currentResult.TestCases.ConditionalAdd(testCaseResult)
			}
		}
	}

	return results, nil
}

func xmlAttributeListToMap(attr []xml.Attr) map[string]string {
	result := map[string]string{}
	for _, attr := range attr {
		result[attr.Name.Local] = attr.Value
	}
	return result
}

// PopulateFingerprintsFromShasumsFile populates the Fingerprint of each test
// result from a file generated by the shasum command.
//
// Fingerprints are used to verify that a test file hasn't been modified since
// the result was generated. If it was, it introduces additional constraints on how
// the test result can be used (see Planner)
func PopulateFingerprintsFromShasumsFile(results TestRunResults, r io.Reader) error {
	whitespace := regexp.MustCompile("\\s+")

	br := bufio.NewReader(r)
	for {
		line, err := br.ReadString('\n')
		if err == io.EOF {
			if line == "" {
				break
			}
		} else if err != nil {
			return err
		}
		line = strings.TrimRight(line, "\r\n")

		fields := whitespace.Split(line, 2)
		if len(fields) < 2 {
			return fmt.Errorf("malformed line, expected two space-separated fields: %v", line)
		}

		fingerprint := fields[0]
		filename := fields[1]
		if result, ok := results[filename]; ok {
			result.Fingerprint = fingerprint
		}
	}

	return nil
}
