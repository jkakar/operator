#!/usr/bin/env bash
#/ Usage: build [--help] [<project>]
set -euo pipefail

: "${REPO_ROOT_DIR:="$(cd "$(dirname "${BASH_SOURCE[0]}")/../../.." && pwd)"}"
: "${BREAD_DIR:="${REPO_ROOT_DIR}/bread"}"
export REPO_ROOT_DIR BREAD_DIR

PATH="$BREAD_DIR/bin:$PATH"
export PATH

# Bring in configuration settings
. "${BREAD_DIR}/etc/buildenv"

# Enable tracing output if DEBUG is set
: "${DEBUG:=""}"
test -n "$DEBUG" && set -x

if [ -z "${GOBIN:-""}" ]; then
    GOBIN="$(mktemp -d)"
    export GOBIN
    trap 'rm -rf "$GOBIN"' EXIT

    PATH="${GOBIN}:$PATH"
    export PATH
fi

: "${GO_PREFIX:="git.dev.pardot.com/Pardot/infrastructure"}"
: "${GO_PREFIX_BREAD:="git.dev.pardot.com/Pardot/infrastructure/bread"}"

project=""
while [ $# -gt 0 ]; do
    case "$1" in
        -h|--help)
            grep ^#/ <"$0" |cut -c4-
            exit 1
            ;;
        *)
            project="$1"
            shift
            ;;
    esac
done

# Bail out in case there is nothing to build. This typically should not happen
# during normal usage and is therefore considered an error (non-zero status code)
if [ -z "$project"  ]; then
    echo "build: Nothing to build." 2>&1
    exit 1
fi

# HACK: Workaround for docker networking issues
if [ -x "/bin/systemctl" ] && [ "$(hostname -f | cut -d. -f2-4)" != "internal.salesforce.com" ]; then
    docker network ls --filter="type=custom" | sed 1d | awk '{print $2}' | xargs -r docker network rm || true
    sudo /bin/systemctl restart docker.service
    sleep 5
fi

# Pull the latest version of the build image unless $NOPULL is set
: "${NOPULL:=""}"
pullopts=""
if [ -z "$NOPULL" ]; then
  pullopts="--pull"
fi
docker build $pullopts -f "${BREAD_DIR}/etc/docker/Dockerfile.build" -t build/build .

# Build citool utility program on CI.
if [ -n "${CI:=""}" ]; then
    docker run --rm -w /go \
    -v "${GOBIN}:/go/bin" \
    -v "${REPO_ROOT_DIR}:/go/src/${GO_PREFIX}" \
    build/build \
    go install -v "${GO_PREFIX_BREAD}/cmd/citool"
fi

build_rubygem() {
    local gemname="$1"
    local gemspec="$2"
    docker run --rm \
        -v "${BREAD_DIR}:/data" \
        -v /etc/env/artifactoryenv:/etc/env/artifactoryenv \
        -e "ARTIFACTORY_HOST=$ARTIFACTORY_HOST" \
        -e "CI_BRANCH=$CI_BRANCH" \
        -e "CI_BUILD_NUMBER=$CI_BUILD_NUMBER" \
        -e "CI_PLAN=$CI_PLAN" \
        -e "DEBUG=$DEBUG" \
        build/build \
        build-rubygem \
        "$gemname" \
        "$gemspec"
}

docker_image() {
    local project="$1"
    local tag="${CI_PROJECT}-${CI_PLAN}-${CI_BUILD_NUMBER}"
    echo "${DOCKER_REPO_BREAD}/${project}/app:${tag}"
}

docker_push() {
    local project="$1"
    local sha1="$(git rev-parse HEAD)"
    local tag="${CI_PROJECT}-${CI_PLAN}-${CI_BUILD_NUMBER}"
    local repo="$(docker_image "$project")"

    echo "Pushing container image to ${repo}..." 2>&1
    docker tag "${project}_app" "$repo"
    docker push "$repo"

    echo "Setting standard properties on container image manifest.json file..." 2>&1

    local props="bambooProject=${CI_PROJECT}|"
    props+="bambooPlan=${CI_PLAN}|"
    props+="bambooJob=${CI_JOB}|"
    props+="buildID=${CI_PROJECT}-${CI_PLAN}-${CI_JOB}-${CI_BUILD_NUMBER}|"
    props+="gitBranch=${CI_BRANCH}|"
    props+="gitRepo=${BAMBOO_REPO_URL}|"
    props+="gitSha=${sha1}|"
    props+="buildNumber=${CI_BUILD_NUMBER}|"
    props+="buildTimeStamp=${BAMBOO_BUILD_TIMESTAMP}|"
    props+="buildResults=${BAMBOO_BUILD_RESULTS_URL}|"
    props+="passedCI=true"
    props+="dockerImageRepository=${DOCKER_REPO_BREAD}/${project}/app"

    local manifest="pd-docker/build/bread/${project}/app/${tag}/manifest.json"
    local apipath="api/storage/$manifest?properties=$props"
    set +x
    curl -f -u "${ARTIFACTORY_USERNAME}:${ARTIFACTORY_PASSWORD}" -X PUT \
      "${ARTIFACTORY_URL}/${apipath}"
    test -n "$DEBUG" && set -x

    true
}

extract_tarball() {
    local project="$1"
    local tarball="$2"
    shift 2

    local sourceopts=()
    while [ "$#" -gt 0 ]; do
        sourceopts+=("-source=$1")
        shift
    done

    citool extract-sources \
        -image="$(docker_image "$project")" \
        -file="$tarball" \
        "${sourceopts[@]}"
}

tarball_upload() {
    local tarball="$1"
    local green="$2"
    local sha1="$(git rev-parse HEAD)"

    docker run --rm \
        -v "${BREAD_DIR}:/data" \
        -v "${tarball}:/data/tarball.tar" \
        -w "/data" \
        -e "ARTIFACTORY_HOST=$ARTIFACTORY_HOST" \
        -e "ARTIFACTORY_REPO_CANOE=$ARTIFACTORY_REPO_CANOE" \
        -e "ARTIFACTORY_URL=$ARTIFACTORY_URL" \
        -e "ARTIFACTORY_USERNAME=$ARTIFACTORY_USERNAME" \
        -e "ARTIFACTORY_PASSWORD=$ARTIFACTORY_PASSWORD" \
        -e "BAMBOO_BUILD_RESULTS_URL=$BAMBOO_BUILD_RESULTS_URL" \
        -e "BAMBOO_BUILD_TIMESTAMP=$BAMBOO_BUILD_TIMESTAMP" \
        -e "BAMBOO_REPO_URL=$BAMBOO_REPO_URL" \
        -e "CANOE_ARTIFACTORY_REPO=$ARTIFACTORY_REPO_CANOE" \
        -e "CI=$CI" \
        -e "CI_PLAN=$CI_PLAN" \
        -e "CI_JOB=$CI_JOB" \
        -e "CI_PROJECT=$CI_PROJECT" \
        -e "CI_BUILD_NUMBER=$CI_BUILD_NUMBER" \
        -e "CI_BRANCH=$CI_BRANCH" \
        build/build \
        tarball-upload "$sha1" "$green" /data/tarball.tar
}

echo "===> Building ${project}..." 2>&1

case "$project" in
    canoe)
        file="${REPO_ROOT_DIR}/terraform/_vendor/src/github.com/hashicorp/terraform/terraform/version.go"
        vendored="$(
          grep "const Version " "$file" |
          sed -e 's/^.*"\(.*\)".*$/\1/'
        )"
        canoe="$(cat "${BREAD_DIR}/canoe/config/terraform-version")"

        if [ "$vendored" != "$canoe" ]; then
          printf "Vendored Terraform version (%s) does not match version required by Canoe: %s\n" \
            "$vendored" "$canoe"
          exit 1
        fi

        build-ruby "$project" "canoe"

        if [ -n "$CI" ]; then
            docker_push "$project"

            tarball="$(mktemp)"
            trap 'rm -f "$tarball"' EXIT
            extract_tarball "$project" "$tarball" "/app:/"
            tarball_upload "$tarball" "true"
        fi

        ;;
    changeling)
        RUBOCOP_CONFIG="etc/rubocop-changeling.yml"
        export RUBOCOP_CONFIG
        build-ruby "$project" "changeling"

        if [ -n "$CI" ]; then
            docker_push "$project"

            tarball="$(mktemp)"
            trap 'rm -f "$tarball"' EXIT
            extract_tarball "$project" "$tarball" "/app:/"
            tarball_upload "$tarball" "true"
        fi
        ;;
    devenv)
        mkdir -p "${BREAD_DIR}/bin/darwin_amd64"
        docker run --rm -w /go \
            -v "${GOBIN}:/go/bin" \
            -v "${REPO_ROOT_DIR}:/go/src/${GO_PREFIX}" \
            -v "${BREAD_DIR}/bin/darwin_amd64:/go/bin/darwin_amd64" \
            -e "GOOS=darwin" \
            -e "GOARCH=amd64" \
            build/build \
            go install -v "${GO_PREFIX_BREAD}/cmd/devenv"
        ;;
    explorer)
        build-ruby "$project" "explorer"

        if [ -n "$CI" ]; then
            # Build a tarball from the app container built above
            tarball="$(tarball-build-ruby "explorer_app")"
            trap 'rm -f "$tarball"' EXIT

            # Update the tarball to Artifactory
            tarball_upload "$tarball" "true"
        fi
        ;;
    golang)
        # Lint (first-party only) then build all Go code
        docker run --rm -w /go \
            -v "${GOBIN}:/go/bin" \
            -v "${REPO_ROOT_DIR}:/go/src/${GO_PREFIX}" \
            build/build \
            make -f "/go/src/${GO_PREFIX_BREAD}/etc/mk/golang.mk"

        # Run the LDAPAuthorizer test, which requires a running LDAP server.
        docker build $pullopts -f "${BREAD_DIR}/etc/docker/Dockerfile.ldap" -t bread/ldap "$BREAD_DIR"
        ldapcontainer="$(docker run -d -v "${BREAD_DIR}/etc/ldap.ldif:/data/ldap.ldif" bread/ldap)"
        trap 'docker stop -t3 $ldapcontainer >/dev/null 2>&1' EXIT
        docker run --rm -w /go \
            -v "${GOBIN}:/go/bin" \
            -v "${REPO_ROOT_DIR}:/go/src/${GO_PREFIX}" \
            --link "$ldapcontainer:ldap" \
            build/build \
            go test -v git.dev.pardot.com/Pardot/infrastructure/bread -ldap -run /LDAPAuth.*/

        if [ -n "$CI" ]; then
          pushd "$GOBIN"
          tarball="$(tarball-build "jiracleaner")"
          tarball_upload "$tarball" "true"

          export CI_JOB="PRIV"
          tarball="$(tarball-build "privet")"
          tarball_upload "$tarball" "true"

          export CI_JOB="CITOOL"
          tarball="$(tarball-build "citool")"
          tarball_upload "$tarball" "true"
          popd

          # Build static operatord binary for Linux
          docker run --rm -w /go \
              -v "/tmp:/tmp" \
              -v "${REPO_ROOT_DIR}:/go/src/${GO_PREFIX}" \
              -e "TMPDIR=/tmp" \
              -e "CGO_ENABLED=0" \
              -e "GOOS=linux" \
              build/build \
	          go build -a -tags netgo -ldflags "-w" -o /tmp/operatord_linux "${GO_PREFIX_BREAD}/cmd/operatord"

          # Build operatord container for deployment
          trap 'rm -f ${BREAD_DIR}/operatord' EXIT
          cp /tmp/operatord_linux "$BREAD_DIR/operatord"
          docker build -f "${BREAD_DIR}/etc/docker/Dockerfile.operatord" -t operatord_app "${BREAD_DIR}"

          # Push operatord Docker container and tarball to Artifactory
          export CI_JOB="OP"
          docker_push "operatord"
          tarball="$(mktemp)"
          trap 'rm -f "$tarball"' EXIT
          extract_tarball "operatord" "$tarball" "/app:/"
          tarball_upload "$tarball" "true"
        fi
        ;;
    hal9000)
        build-ruby "$project" "hal9000"

        if [ -n "$CI" ]; then
            docker_push "$project"
        fi
        ;;
    operator)
        true
        ;;
    parbot)
        docker build $pullopts -f "${BREAD_DIR}/parbot/Dockerfile" -t parbot_app "${BREAD_DIR}/parbot"
        docker run parbot_app script/lint

        if [ -n "$CI" ]; then
            docker_push "$project"

            tarball="$(mktemp)"
            trap 'rm -f "$tarball"' EXIT
            extract_tarball "${project}" "$tarball" "/app:/"
            tarball_upload "$tarball" "true"
        fi
        ;;
    pd-sync-chef)
        # This is a fork of <https://github.com/PagerDuty/pd-sync-chef> which
        # does not follow the strict formatting and styles rules we normally
        # enforce for Ruby code within this repository so we skip the lint check
        build-ruby --no-lint "$project" "pd-sync-chef"

        if [ -n "$CI" ]; then
            build_rubygem "pardot_chef-sync" \
                "pd-sync-chef/pardot_chef-sync.gemspec"
        fi
        ;;
    pull_agent)
        build-ruby "$project" "pull_agent"

        if [ -n "$CI" ]; then
            build_rubygem "pardot_pull-agent" \
                "pull_agent/pardot_pull-agent.gemspec"
        fi
        ;;
    rubylib)
        build-ruby "rubylib" "rubylib"
        ;;
    shell)
        # Build a container image with the shellcheck package installed.
        # Unfortunately installing shellcheck on CentOS is non-trivial so this
        # an Ubuntu image.
        docker build $pullopts \
            -f "${BREAD_DIR}/etc/docker/Dockerfile.shellcheck" -t build/shellcheck "${BREAD_DIR}"

        # Lint all shell scripts
        docker run --rm -v "${BREAD_DIR}:/data" \
            -e "PATH=/data/tools/build:$PATH" build/shellcheck lint-shell
        ;;
    teampass)
        docker build $pullopts \
            -f "${BREAD_DIR}/teampass/Dockerfile" -t teampass_app "${BREAD_DIR}/teampass"

        if [ -n "$CI" ]; then
            docker_push "$project"
        fi
        ;;
    terraform)
        docker run --rm -w /go \
            -v "${GOBIN}:/go/bin" \
            -v "${REPO_ROOT_DIR}:/go/src/${GO_PREFIX}" \
            -e "GOBIN=/go/bin" \
            -e "ROOT_DIR=/go/src/${GO_PREFIX}" \
            build/build \
            "/go/src/${GO_PREFIX}/bin/terra" validate
        ;;
    *)
        echo "Unknown project: $project" 2>&1
        exit 1
        ;;
esac
