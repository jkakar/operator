package privet

import (
	"bufio"
	"fmt"
	"io"
	"regexp"
	"time"

	"gopkg.in/xmlpath.v2"
)

type TestCaseResult struct {
	Name     string
	Duration time.Duration
}

type TestFileResult struct {
	Name        string
	Filename    string
	Fingerprint string
	Duration    time.Duration
	TestCases   []*TestCaseResult
}

type TestRunResults map[string]*TestFileResult

var (
	junitResultTestSuitePath     = xmlpath.MustCompile(`//testsuite[@file]`)
	junitResultTestCasePath      = xmlpath.MustCompile(`//testcase`)
	junitResultFileAttributePath = xmlpath.MustCompile(`@file`)
	junitResultNameAttributePath = xmlpath.MustCompile(`@name`)
	junitResultTimeAttributePath = xmlpath.MustCompile(`@time`)
)

// ParseJunitResult parses a JUnit result file into a list of TestFileResult
// structs, describing the attributes of a previous test run.
func ParseJunitResult(r io.Reader) (TestRunResults, error) {
	node, err := xmlpath.Parse(r)
	if err != nil {
		return nil, err
	}

	results := make(TestRunResults)
	suiteFileNodes := junitResultTestSuitePath.Iter(node)
	for suiteFileNodes.Next() {
		fileNode := suiteFileNodes.Node()
		file, _ := junitResultFileAttributePath.String(fileNode)
		name, _ := junitResultNameAttributePath.String(fileNode)
		timeStr, _ := junitResultTimeAttributePath.String(fileNode)
		timeDuration, err := time.ParseDuration(fmt.Sprintf("%ss", timeStr))
		if err != nil {
			timeDuration = 0
		}

		result := &TestFileResult{
			Filename:  file,
			Name:      name,
			Duration:  timeDuration,
			TestCases: []*TestCaseResult{},
		}

		testCaseNodes := junitResultTestCasePath.Iter(fileNode)
		for testCaseNodes.Next() {
			testCaseNode := testCaseNodes.Node()
			name, _ = junitResultNameAttributePath.String(testCaseNode)
			timeStr, _ = junitResultTimeAttributePath.String(testCaseNode)
			timeDuration, err := time.ParseDuration(fmt.Sprintf("%ss", timeStr))
			if err != nil {
				timeDuration = 0
			}

			testCase := &TestCaseResult{
				Name:     name,
				Duration: timeDuration,
			}
			result.TestCases = append(result.TestCases, testCase)
		}

		results[file] = result
	}

	return results, nil
}

// PopulateFingerprintsFromShasumsFile populates the Fingerprint of each test
// result from a file generated by the shasum command.
//
// Fingerprints are used to verify that a test file hasn't been modified since
// the result was generated. If it was, it introduces additional constraints on how
// the test result can be used (see Planner)
func PopulateFingerprintsFromShasumsFile(results TestRunResults, r io.Reader) error {
	whitespace := regexp.MustCompile("\\s+")

	br := bufio.NewReader(r)
	for {
		line, err := br.ReadString('\n')
		if err == io.EOF {
			if line == "" {
				break
			}
		} else if err != nil {
			return err
		}

		fields := whitespace.Split(line, 2)
		if len(fields) < 2 {
			return fmt.Errorf("malformed line, expected two space-separated fields: %v", line)
		}

		fingerprint := fields[0]
		filename := fields[1]
		if result, ok := results[filename]; ok {
			result.Fingerprint = fingerprint
		}
	}

	return nil
}
