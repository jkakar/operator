package privet

import (
	"bufio"
	"encoding/xml"
	"fmt"
	"io"
	"regexp"
	"strings"
	"time"
)

type TestCaseResult struct {
	Name     string
	Duration time.Duration
}

type TestFileResult struct {
	Name        string
	Filename    string
	Fingerprint string
	Duration    time.Duration
	TestCases   map[string]*TestCaseResult
}

type TestRunResults map[string]*TestFileResult

// Merge merges test run tests. Because we might bust up individual files into
// smaller chunks of test cases, to get an accurate sense of duration and the
// number of test cases in each file, we must merge individual test cases batch
// together after parsing the results.
func (r TestRunResults) Merge(o TestRunResults) {
	for key, otherResult := range o {
		if result, ok := r[key]; ok {
			result.Duration += otherResult.Duration
			for name, testCase := range otherResult.TestCases {
				result.TestCases[name] = testCase
			}
		} else {
			r[key] = otherResult
		}
	}
}

// ParseJunitResult parses a JUnit result file into a list of TestFileResult
// structs, describing the attributes of a previous test run.
func ParseJunitResult(r io.Reader) (TestRunResults, error) {
	results := TestRunResults{}

	decoder := xml.NewDecoder(r)
	var currentResult *TestFileResult
	for {
		token, err := decoder.Token()
		if err == io.EOF {
			break
		} else if err != nil {
			return nil, err
		}

		switch element := token.(type) {
		case xml.StartElement:
			if element.Name.Local == "testsuite" {
				attrMap := xmlAttributeListToMap(element.Attr)

				// If the <testcase> doesn't have a file
				// attribute, we're not interested in it. It's
				// either the outermost <testsuite> representing a
				// --group or it's an innermost <testsuite>
				// representing a group of test cases with data
				// sets
				if attrMap["name"] == "" || attrMap["file"] == "" {
					continue
				}

				currentResult = &TestFileResult{
					Name:      attrMap["name"],
					Filename:  attrMap["file"],
					TestCases: map[string]*TestCaseResult{},
				}
				if timeValue, ok := attrMap["time"]; ok {
					currentResult.Duration, _ = time.ParseDuration(fmt.Sprintf("%ss", timeValue))
				}
				results[currentResult.Filename] = currentResult
			} else if element.Name.Local == "testcase" {
				attrMap := xmlAttributeListToMap(element.Attr)

				if attrMap["name"] == "" {
					continue
				} else if currentResult == nil {
					continue
				}

				testCaseResult := &TestCaseResult{
					Name: attrMap["name"],
				}
				if timeValue, ok := attrMap["time"]; ok {
					testCaseResult.Duration, _ = time.ParseDuration(fmt.Sprintf("%ss", timeValue))
				}
				currentResult.TestCases[testCaseResult.Name] = testCaseResult
			}
		}
	}

	return results, nil
}

func xmlAttributeListToMap(attr []xml.Attr) map[string]string {
	result := map[string]string{}
	for _, attr := range attr {
		result[attr.Name.Local] = attr.Value
	}
	return result
}

// PopulateFingerprintsFromShasumsFile populates the Fingerprint of each test
// result from a file generated by the shasum command.
//
// Fingerprints are used to verify that a test file hasn't been modified since
// the result was generated. If it was, it introduces additional constraints on how
// the test result can be used (see Planner)
func PopulateFingerprintsFromShasumsFile(results TestRunResults, r io.Reader) error {
	whitespace := regexp.MustCompile("\\s+")

	br := bufio.NewReader(r)
	for {
		line, err := br.ReadString('\n')
		if err == io.EOF {
			if line == "" {
				break
			}
		} else if err != nil {
			return err
		}
		line = strings.TrimRight(line, "\r\n")

		fields := whitespace.Split(line, 2)
		if len(fields) < 2 {
			return fmt.Errorf("malformed line, expected two space-separated fields: %v", line)
		}

		fingerprint := fields[0]
		filename := fields[1]
		if result, ok := results[filename]; ok {
			result.Fingerprint = fingerprint
		}
	}

	return nil
}
