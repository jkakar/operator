#!/usr/bin/env bash
#/ Usage: build [--help] [<project>]
#/ Build program for the BREAD team repository.
set -euo pipefail
cd "$(dirname "$0")/../.."

PATH="$(pwd)/bin:$PATH"
export PATH

# Bring in configuration settings
. etc/build/env

: "${DEBUG:=""}"
test -n "$DEBUG" && set -x

usage() {
    grep ^#/ <"$0" |cut -c4-
    exit 1
}

project=""
while [ $# -gt 0 ]
do
    case "$1" in
        -h|--help)
            usage
            ;;
        *)
            project="$1"
            shift
            ;;
    esac
done

# Bail out in case there is nothing to build. This typically does should not
# happen during normal usage and is therefore considered an error.
test -z "$project"  && {
    echo "build: Nothing to build." 2>&1
    exit 1
}

# Workaround docker networking bug
docker-hack-restart

# HACK: Override Artifactory host name on CI machines to workaround this:
# https://jira.dev.pardot.com/browse/BREAD-797
if [ -n "$CI"  ]
then
    find src -type f -name Gemfile -print0 |
    xargs -0 sed -i.bak -e's/artifactory\.dev\.pardot\.com/artifactory-internal\.dev\.pardot\.com/g'
    ARTIFACTORY_HOST="artifactory-internal.dev.pardot.com"
    export ARTIFACTORY_HOST
    unset -v ARTIFACTORY_URL
fi

# Build the container used for most builds.
if [ -n "$CI" ]
then docker build --pull -f etc/docker/Dockerfile.build -t build/build .
else docker build -f etc/docker/Dockerfile.build -t build/build .
fi

echo "===> Building ${project}..." 2>&1

case "$project" in
    canoe)
        build-ruby "$project"
        test -n "$CI" && docker-push "canoe_app" "$CANOE_ECR_REPO"
        ;;
    explorer)
        build-ruby "$project"
        test -n "$CI" && {
            # Build a tarball from the app container built above
            tarball="$(tarball-build-ruby "explorer_app")"
            trap 'rm -f $tarball' EXIT

            # Prepare the tarball and upload it to Artifactory
            docker-tarball-upload "$(git rev-parse HEAD)" "$tarball" "true"
        }
        ;;
    golang)
        docker run --rm -w /go -v "$(pwd):/go" build/build \
            make -f etc/mk/golang.mk
        ;;
    pull_agent)
        build-ruby "$project"

        # Build the gem and push it to Artifactory on CI.
        test -n "$CI" && {
            docker run --rm \
                -v "$(pwd):/data" \
                -v /etc/env/artifactoryenv:/etc/env/artifactoryenv \
                -e "ARTIFACTORY_HOST=$ARTIFACTORY_HOST" \
                -e "CI_BRANCH=$CI_BRANCH" \
                -e "CI_BUILD_NUMBER=$CI_BUILD_NUMBER" \
                -e "CI_PLAN=$CI_PLAN" \
                -e "DEBUG=$DEBUG" \
                build/build \
                build-gem-pull_agent
        }
        ;;
    rubylib)
        build-ruby "rubylib"
        ;;
    shell)
        docker build -f etc/docker/Dockerfile.shellcheck -t build/shellcheck .
        docker run --rm -v "$(pwd):/data" \
            build/shellcheck \
            find src/build -maxdepth 1 -type f -exec shellcheck -f gcc {} +
        ;;
    teampass)
        docker build -f src/teampass/Dockerfile src/teampass
        ;;
    terraform)
        docker run --rm -v "$(pwd):/data" \
            build/build \
            make -C src/terraform validate
        ;;
    # TODO(sr) Decide what to do about vendored Go code. I think building
    # it might be worthwhile still, just not with the same level of
    # attention as for our own code, so no linting etc.
    vendor)
        true
        ;;
    *)
        echo "No build rule defined for project \"$project\"." 2>&1
        exit 1
        ;;
esac
