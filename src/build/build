#!/usr/bin/env bash
#/ Usage: build [--help] [<project>]
#/ Build program for the BREAD team repository.
set -euo pipefail
cd "$(dirname "$0")/../.."

: "${BREAD:="$(pwd)"}"
export BREAD

PATH="$BREAD/bin:$PATH"
export PATH

# Bring in configuration settings
. "$BREAD/etc/buildenv"

# Enable tracing output if DEBUG is set
: "${DEBUG:=""}"
test -n "$DEBUG" && set -x

if [ -z "${GOBIN:-""}" ]; then
    GOBIN="$(mktemp -d)"
    export GOBIN
    trap 'rm -rf "$GOBIN"' EXIT

    PATH="${GOBIN}:$PATH"
    export PATH
fi

: "${GO_PREFIX:="git.dev.pardot.com/Pardot/bread"}"
export GO_PREFIX

project=""
while [ $# -gt 0 ]; do
    case "$1" in
        -h|--help)
            grep ^#/ <"$0" |cut -c4-
            exit 1
            ;;
        *)
            project="$1"
            shift
            ;;
    esac
done

# Bail out in case there is nothing to build. This typically should not happen
# during normal usage and is therefore considered an error (non-zero status code)
if [ -z "$project"  ]; then
    echo "build: Nothing to build." 2>&1
    exit 1
fi

# HACK: Workaround for docker networking issues
if [ -x "/bin/systemctl" ] && [ "$(hostname -f | cut -d. -f2-4)" != "internal.salesforce.com" ]; then
    docker network ls --filter="type=custom" | sed 1d | awk '{print $2}' | xargs -r docker network rm || true
    sudo /bin/systemctl restart docker.service
    sleep 5
fi

# HACK: Override Artifactory hostname on CI machines to workaround BREAD-797
if [ -n "$CI" ]; then
    find src -type f -name Gemfile -print0 |
    xargs -0 sed -i.bak -e's/artifactory\.dev\.pardot\.com/artifactory-internal\.dev\.pardot\.com/g'
    ARTIFACTORY_HOST="artifactory-internal.dev.pardot.com"
    ARTIFACTORY_URL="https://${ARTIFACTORY_HOST}/artifactory"
    export ARTIFACTORY_HOST ARTIFACTORY_URL
fi

# Pull the latest version of the build image unless $NOPULL is set
: "${NOPULL:=""}"
pullopts=""
if [ -z "$NOPULL" ]; then
  pullopts="--pull"
fi
docker build $pullopts -f etc/docker/Dockerfile.build -t build/build .

# Build citool utility program
docker run --rm -w /go \
   -v "$GOBIN:/go/bin" \
   -v "$BREAD:/go/src/${GO_PREFIX}" \
   build/build \
   go install -v "${GO_PREFIX}/cmd/citool"

build_rubygem() {
    local gemname="$1"
    local gemspec="$2"
    docker run --rm \
        -v "$BREAD:/data" \
        -v /etc/env/artifactoryenv:/etc/env/artifactoryenv \
        -e "ARTIFACTORY_HOST=$ARTIFACTORY_HOST" \
        -e "CI_BRANCH=$CI_BRANCH" \
        -e "CI_BUILD_NUMBER=$CI_BUILD_NUMBER" \
        -e "CI_PLAN=$CI_PLAN" \
        -e "DEBUG=$DEBUG" \
        build/build \
        build-rubygem \
        "$gemname" \
        "$gemspec"
}

docker_image() {
    local project="$1"
    local tag="${CI_PROJECT}-${CI_PLAN}-${CI_BUILD_NUMBER}"
    echo "${DOCKER_REPO_BREAD}/${project}/app:${tag}"
}

docker_push() {
    local project="$1"
    local sha1="$(git rev-parse HEAD)"
    local tag="${CI_PROJECT}-${CI_PLAN}-${CI_BUILD_NUMBER}"
    local repo="$(docker_image "$project")"

    echo "Pushing container image to ${repo}..." 2>&1
    docker tag "${project}_app" "$repo"
    docker push "$repo"

    echo "Setting standard properties on container image manifest.json file..." 2>&1

    local props="bambooProject=${CI_PROJECT}|"
    props+="bambooPlan=${CI_PLAN}|"
    props+="bambooJob=${CI_JOB}|"
    props+="buildID=${CI_PROJECT}-${CI_PLAN}-${CI_JOB}-${CI_BUILD_NUMBER}|"
    props+="gitBranch=${CI_BRANCH}|"
    props+="gitRepo=${BAMBOO_REPO_URL}|"
    props+="gitSha=${sha1}|"
    props+="buildNumber=${CI_BUILD_NUMBER}|"
    props+="buildTimeStamp=${BAMBOO_BUILD_TIMESTAMP}|"
    props+="buildResults=${BAMBOO_BUILD_RESULTS_URL}|"
    props+="passedCI=true"
    props+="dockerImageRepository=${DOCKER_REPO_BREAD}/${project}/app"

    local manifest="pd-docker/build/bread/${project}/app/${tag}/manifest.json"
    local apipath="api/storage/$manifest?properties=$props"
    set +x
    curl -f -u "${ARTIFACTORY_USERNAME}:${ARTIFACTORY_PASSWORD}" -X PUT \
      "${ARTIFACTORY_URL}/${apipath}"
    test -n "$DEBUG" && set -x

    true
}

extract_tarball() {
    local project="$1"
    local tarball="$2"
    shift 2

    local sourceopts=()
    while [ "$#" -gt 0 ]; do
        sourceopts+=("-source=$1")
        shift
    done

    citool extract-sources \
        -image="$(docker_image "$project")" \
        -file="$tarball" \
        "${sourceopts[@]}"
}

tarball_upload() {
    local tarball="$1"
    local green="$2"
    local sha1="$(git rev-parse HEAD)"

    docker run --rm \
        -v "$BREAD:/data" \
        -v "${tarball}:/data/tarball.tar" \
        -w "/data" \
        -e "ARTIFACTORY_HOST=$ARTIFACTORY_HOST" \
        -e "ARTIFACTORY_REPO_CANOE=$ARTIFACTORY_REPO_CANOE" \
        -e "ARTIFACTORY_URL=$ARTIFACTORY_URL" \
        -e "ARTIFACTORY_USERNAME=$ARTIFACTORY_USERNAME" \
        -e "ARTIFACTORY_PASSWORD=$ARTIFACTORY_PASSWORD" \
        -e "BAMBOO_BUILD_RESULTS_URL=$BAMBOO_BUILD_RESULTS_URL" \
        -e "BAMBOO_BUILD_TIMESTAMP=$BAMBOO_BUILD_TIMESTAMP" \
        -e "BAMBOO_REPO_URL=$BAMBOO_REPO_URL" \
        -e "CANOE_ARTIFACTORY_REPO=$ARTIFACTORY_REPO_CANOE" \
        -e "CI=$CI" \
        -e "CI_PLAN=$CI_PLAN" \
        -e "CI_JOB=$CI_JOB" \
        -e "CI_PROJECT=$CI_PROJECT" \
        -e "CI_BUILD_NUMBER=$CI_BUILD_NUMBER" \
        -e "CI_BRANCH=$CI_BRANCH" \
        build/build \
        tarball-upload "$sha1" "$green" /data/tarball.tar
}

echo "===> Building ${project}..." 2>&1

case "$project" in
    canoe)
        build-ruby "$project"

        file="${BREAD}/src/terraform/_vendor/src/github.com/hashicorp/terraform/terraform/version.go"
        vendored="$(
          grep "const Version " "$file" |
          sed -e 's/^.*"\(.*\)".*$/\1/'
        )"
        canoe="$(cat src/canoe/config/terraform-version)"

        if [ "$vendored" != "$canoe" ]; then
          printf "Vendored Terraform version (%s) does not match version required by Canoe: %s\n" \
            "$vendored" "$canoe"
          exit 1
        fi

        if [ -n "$CI" ]; then
            docker_push "$project"

            tarball="$(mktemp)"
            trap 'rm -f "$tarball"' EXIT
            extract_tarball "$project" "$tarball" "/app:/"
            tarball_upload "$tarball" "true"
        fi

        ;;
    changeling)
        RUBOCOP_CONFIG="etc/rubocop-changeling.yml"
        export RUBOCOP_CONFIG
        build-ruby "$project"

        if [ -n "$CI" ]; then
            docker_push "$project"

            tarball="$(mktemp)"
            trap 'rm -f "$tarball"' EXIT
            extract_tarball "$project" "$tarball" "/app:/"
            tarball_upload "$tarball" "true"
        fi
        ;;
    devenv)
        mkdir -p "${BREAD}/bin/darwin_amd64"
        docker run --rm -w /go \
            -v "${GOBIN}:/go/bin" \
            -v "${BREAD}:/go/src/${GO_PREFIX}" \
            -v "${BREAD}/bin/darwin_amd64:/go/bin/darwin_amd64" \
            -e "GOOS=darwin" \
            -e "GOARCH=amd64" \
            build/build \
            go install -v "${GO_PREFIX}/cmd/devenv"
        ;;
    explorer)
        build-ruby "$project"

        if [ -n "$CI" ]; then
            # Build a tarball from the app container built above
            tarball="$(tarball-build-ruby "explorer_app")"
            trap 'rm -f "$tarball"' EXIT

            # Update the tarball to Artifactory
            tarball_upload "$tarball" "true"
        fi
        ;;
    golang)
        # Start a test LDAP server. This is used by test suite of the "bread" package
        docker build $pullopts -f etc/docker/Dockerfile.ldap -t bread/ldap "$BREAD"
        ldapcontainer="$(docker run -d -v "${BREAD}/etc/ldap.ldif:/data/ldap.ldif" bread/ldap)"
        trap 'docker stop -t3 $ldapcontainer >/dev/null 2>&1' EXIT

        # Lint (first-party only) then build all Go code
        docker run --rm -w /go \
            -v "${GOBIN}:/go/bin" \
            -v "$BREAD:/go/src/${GO_PREFIX}" \
            --link "$ldapcontainer:ldap" \
            build/build \
            make -f "/go/src/${GO_PREFIX}/etc/mk/golang.mk"

        if [ -n "$CI" ]; then
          pushd "$GOBIN"
          tarball="$(tarball-build "jiracleaner")"
          tarball_upload "$tarball" "true"

          export CI_JOB="PRIV"
          tarball="$(tarball-build "privet")"
          tarball_upload "$tarball" "true"

          export CI_JOB="CITOOL"
          tarball="$(tarball-build "citool")"
          tarball_upload "$tarball" "true"
          popd

          # Build static operatord binary for Linux
          docker run --rm -w /go \
              -v "/tmp:/tmp" \
              -v "$BREAD:/go/src/${GO_PREFIX}" \
              -e "TMPDIR=/tmp" \
              build/build \
              make -f "/go/src/${GO_PREFIX}/etc/mk/operator.mk" build-operatord

          # Build operatord container for deployment
          trap 'rm -f $BREAD/operatord' EXIT
          cp /tmp/operatord_linux "$BREAD/operatord"
          make -f etc/mk/operator.mk docker-build-operatord

          # Push operatord Docker container and tarball to Artifactory
          export CI_JOB="OP"
          docker_push "operatord"
          tarball="$(mktemp)"
          trap 'rm -f "$tarball"' EXIT
          extract_tarball "operatord" "$tarball" "/app:/"
          tarball_upload "$tarball" "true"
        fi
        ;;
    hal9000)
        build-ruby "$project"

        if [ -n "$CI" ]; then
            docker_push "$project"
        fi
        ;;
    operator)
        true
        ;;
    parbot)
        docker build $pullopts -f "$BREAD/src/parbot/Dockerfile" -t parbot_app "$BREAD/src/parbot"
        docker run parbot_app script/lint

        if [ -n "$CI" ]; then
            docker_push "$project"

            tarball="$(mktemp)"
            trap 'rm -f "$tarball"' EXIT
            extract_tarball "${project}" "$tarball" "/app:/"
            tarball_upload "$tarball" "true"
        fi
        ;;
    pd-sync-chef)
        # This is a fork of <https://github.com/PagerDuty/pd-sync-chef> which
        # does not follow the strict formatting and styles rules we normally
        # enforce for Ruby code within this repository so we skip the lint check
        build-ruby --no-lint "$project"

        if [ -n "$CI" ]; then
            build_rubygem "pardot_chef-sync" \
                "src/pd-sync-chef/pardot_chef-sync.gemspec"
        fi
        ;;
    pull_agent)
        build-ruby "$project"

        if [ -n "$CI" ]; then
            build_rubygem "pardot_pull-agent" \
                "src/pull_agent/pardot_pull-agent.gemspec"
        fi
        ;;
    rubylib)
        build-ruby "rubylib"
        ;;
    shell)
        # Build a container image with the shellcheck package installed.
        # Unfortunately installing shellcheck on CentOS is non-trivial so this
        # an Ubuntu image.
        docker build $pullopts \
            -f etc/docker/Dockerfile.shellcheck -t build/shellcheck .

        # Lint all shell scripts
        docker run --rm -v "$BREAD:/data" \
            -e "PATH=/data/src/build:$PATH" build/shellcheck lint-shell
        ;;
    teampass)
        docker build $pullopts \
            -f src/teampass/Dockerfile -t teampass_app src/teampass

        if [ -n "$CI" ]; then
            docker_push "$project"
        fi
        ;;
    terraform)
        docker run --rm -w /go \
            -v "${GOBIN}:/go/bin" \
            -v "$BREAD:/go/src/${GO_PREFIX}" \
            -e "GOBIN=/go/bin" \
            build/build \
            "/go/src/${GO_PREFIX}/bin/terra" validate

        tarball="$(mktemp -t "bread-terraformXXXXX").tar"
        trap 'rm $tarball' EXIT
        docker run --rm -v "$BREAD:/data" -w "/data" build/build \
          git archive "$(git rev-parse HEAD)" src/terraform > "$tarball"

        if [ -n "$CI" ]; then
          tarball_upload "$tarball" "true"
        fi
        ;;
    *)
        echo "Unknown project: $project" 2>&1
        exit 1
        ;;
esac
