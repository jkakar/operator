#!/usr/bin/env bash
#/ Usage: build [--help] [<project>]
#/ Build program for the BREAD team repository.
set -euo pipefail
cd "$(dirname "$0")/../.."

PATH="$(pwd)/bin:$PATH"
export PATH

# Bring in configuration settings
. etc/build/env

: "${DEBUG:=""}"
test -n "$DEBUG" && set -x

: "${NOPULL:=""}"
pullopts=""
if [ -z "$NOPULL" ]; then
  pullopts="--pull"
fi

usage() {
    grep ^#/ <"$0" |cut -c4-
    exit 1
}

project=""
while [ $# -gt 0 ]
do
    case "$1" in
        -h|--help)
            usage
            ;;
        *)
            project="$1"
            shift
            ;;
    esac
done

# Bail out in case there is nothing to build. This typically does should not
# happen during normal usage and is therefore considered an error.
test -z "$project"  && {
    echo "build: Nothing to build." 2>&1
    exit 1
}

# Workaround docker networking bug
docker-hack-restart

# HACK: Override Artifactory host name on CI machines to workaround this:
# https://jira.dev.pardot.com/browse/BREAD-797
if [ -n "$CI" ]
then
    find src -type f -name Gemfile -print0 |
    xargs -0 sed -i.bak -e's/artifactory\.dev\.pardot\.com/artifactory-internal\.dev\.pardot\.com/g'
    ARTIFACTORY_HOST="artifactory-internal.dev.pardot.com"
    export ARTIFACTORY_HOST
    unset -v ARTIFACTORY_URL
fi

docker build $pullopts -f etc/docker/Dockerfile.build -t build/build .

build_rubygem() {
    docker run --rm \
        -v "$(pwd):/data" \
        -v /etc/env/artifactoryenv:/etc/env/artifactoryenv \
        -e "ARTIFACTORY_HOST=$ARTIFACTORY_HOST" \
        -e "CI_BRANCH=$CI_BRANCH" \
        -e "CI_BUILD_NUMBER=$CI_BUILD_NUMBER" \
        -e "CI_PLAN=$CI_PLAN" \
        -e "DEBUG=$DEBUG" \
        build/build \
        build-rubygem \
        "$1" \
        "$2"
}

echo "===> Building ${project}..." 2>&1

case "$project" in
    canoe)
        build-ruby "$project"
        test -n "$CI" && docker-push "$project"
        ;;
    explorer)
        build-ruby "$project"
        test -n "$CI" && {
            # Build a tarball from the app container built above
            tarball="$(tarball-build-ruby "explorer_app")"
            trap 'rm -f $tarball' EXIT

            # Prepare the tarball and upload it to Artifactory
            docker-tarball-upload "$(git rev-parse HEAD)" "$tarball" "true"
        }
        ;;
    devenv)
        docker run --rm -w /go -v "$(pwd):/go" \
            -e "GOOS=darwin" -e "GOARCH=amd64" build/build \
            make -f etc/mk/golang.mk install-devenv
        ;;
    golang)
        docker run --rm -w /go -v "$(pwd):/go" build/build \
            make -f etc/mk/golang.mk

        if [ -n "$CI" ]; then
          pushd "bin"
          tarball="$(tarball-build "jiracleaner")"
          docker-tarball-upload "$(git rev-parse HEAD)" "$tarball" "true"
          export CI_JOB="PRIV"
          tarball="$(tarball-build "privet")"
          docker-tarball-upload "$(git rev-parse HEAD)" "$tarball" "true"
          popd
        fi
        ;;
    hal9000)
        build-ruby "$project"
        test -n "$CI" && docker-push "$project"
        ;;
    operator)
        # TODO(sr) Do this for all builds
        BREAD="$(pwd)"
        export BREAD

        docker run --rm -w /go -v "$(pwd):/go" \
            -e PACKAGES=bread/cmd/operatord \
            build/build \
            make -f etc/mk/golang.mk

        docker run --rm -w /go -v "/tmp:/tmp" -v "$(pwd):/go" \
            -e TMPDIR=/tmp \
            build/build \
            make -f etc/mk/operator.mk build-operatord

        trap 'rm -f $BREAD/operatord' EXIT
        cp /tmp/operatord_linux "$BREAD/operatord"
        make -f etc/mk/operator.mk docker-build-operatord

        if [ -n "$CI" ]; then
            docker-push "${project}d"
        fi
        ;;
    parbot)
        parbotdir="${PARBOT_DIR:-""}"
        echo "$parbotdir"
        if [ -z "$parbotdir" ] || [ ! -d "$parbotdir" ]; then
            echo "PARBOT_DIR not set or directory does not exists" 2>&1
            exit 1
        fi

        trap 'rm -f $parbotdir/Dockerfile' EXIT
        cp etc/docker/Dockerfile.parbot "$parbotdir/Dockerfile"
        docker build $pullopts -f "$parbotdir/Dockerfile" -t parbot_app "$parbotdir"

        test -n "$CI" && docker-push "$project"
        ;;
    pd-sync-chef)
        build-ruby --no-lint "$project"

        test -n "$CI" &&
        build_rubygem "pardot_chef-sync" "src/pd-sync-chef/pardot_chef-sync.gemspec"
        ;;
    pull_agent)
        build-ruby "$project"

        test -n "$CI" && {
            build_rubygem "pardot_pull-agent" \
                "src/pull_agent/pardot_pull-agent.gemspec"
        }
        ;;
    rubylib)
        build-ruby "rubylib"
        ;;
    shell)
        docker build $pullopts -f etc/docker/Dockerfile.shellcheck -t build/shellcheck .
        docker run --rm -v "$(pwd):/data" -e "PATH=/data/src/build:$PATH" \
            build/shellcheck lint-shell
        ;;
    teampass)
        docker build $pullopts -f src/teampass/Dockerfile -t teampass_app src/teampass
        test -n "$CI" && docker-push "$project"
        ;;
    terraform)
        docker run -e "GOPATH=/data" --rm -v "$(pwd):/data" \
            build/build \
            terra validate
        ;;
    *)
        echo "No build rule defined for project \"$project\"." 2>&1
        exit 1
        ;;
esac
