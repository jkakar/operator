package main

import "github.com/sr/operator/src/generator"

var (
	mainUsageTemplate = generator.NewTemplate("main",
		`Usage: {{.Options.BinaryName}} <service> <command>

Use  "{{.Options.BinaryName}} help <service>" for help with a particular service.

Available services:
{{range .Services}}
{{.Name}}
{{wrappedIndent .Description "  "}}
{{end}}`)

	serviceUsageTemplate = generator.NewTemplate("service",
		`Usage: {{.BinaryName}} {{dasherize .Service.Name}} [command]

{{wrap .Service.Description}}

Available Commands:
{{range .Service.Methods}}
{{dasherize .Name}}
{{wrappedIndent .Description " "}}
{{end}}`)

	methodUsageTemplate = generator.NewTemplate("service",
		`Usage: {{.BinaryName}} {{dasherize .Service.Name}} {{dasherize .Name}} [arguments]

{{wrap .Description}}`)

	mainTemplate = generator.NewTemplate("main-gen.go",
		`// Code generated by protoc-gen-operatorcmd
package main

import (
	"golang.org/x/net/context"
	"google.golang.org/grpc"
	"flag"
	"fmt"
	"os"
	"go.pedge.io/env"
	{{- range .Services}}
	{{.PackageName}} "{{.ImportPath}}"
	{{- end}}
)

const (
	usage = `+"`"+`{{.MainUsage}}`+"`"+`

{{- range .Services}}
	usageService{{camelCase .Name}} = `+"`"+`{{index $.ServiceUsage .Name}}`+"`"+`
	{{ $service := .Name }}
	{{- range .Methods}}
	usageService{{camelCase $service}}{{.Name}} = `+"`"+`{{index $.MethodUsage  $service .Name}}`+"`"+`
	{{- end -}}
{{- end -}}
)

type mainEnv struct {
	Address string `+"`"+`env:"OPERATORD_ADDRESS,default=localhost:3000"`+"`"+`
}

func dial(address string) (*grpc.ClientConn, error) {
	conn, err := grpc.Dial(address, grpc.WithInsecure())
	if err != nil {
		return nil, err
	}
	return conn, nil
}

func isHelp(arg string) bool {
	return arg == "-h" || arg == "--help" || arg == "help"
}

{{- range .Services}}
{{- $serviceName := .Name }}
{{- $serviceFullName := .FullName }}
{{- range .Methods}}
func do{{ camelCase $serviceName }}{{.Name}}(address string) (string, error) {
	flags := flag.NewFlagSet("{{dasherize .Name}}", flag.ExitOnError)
	{{- range .Arguments}}
	{{.Name}} := flags.String("{{dasherize .Name}}", "", "")
	{{- end}}
	flags.Parse(os.Args[3:])
	if isHelp(os.Args[3]) {
		fmt.Fprintf(os.Stderr, "%s\n\n", usageService{{camelCase $serviceName}}{{.Name}})
		flags.PrintDefaults()
		os.Exit(2)
	}
	conn, err := dial(address)
	if err != nil {
		return "", err
	}
	defer conn.Close()
	client := {{$serviceName}}.New{{$serviceFullName}}Client(conn)
	response, err := client.{{.Name}}(
		context.Background(),
		&{{$serviceName}}.{{.Input}}{
			{{- range .Arguments}}
			{{camelCase .Name}}: *{{.Name}},
			{{- end}}
		},
	)
	if err != nil {
		return "", err
	}
	return response.Output.PlainText, nil
}
{{end -}}
{{end -}}

func main() {
	status, output, err := run()
	if status != 0 {
		var errS string
		if output == "" {
			errS = err.Error()
		} else {
			errS = output
		}
		fmt.Fprintf(os.Stderr, "%s\n", errS)
		os.Exit(1)
	}
	fmt.Fprintf(os.Stdout, "%s\n", output)
	os.Exit(0)
}

func run() (int, string, error) {
	config := &mainEnv{}
	if err := env.Populate(config); err != nil {
		return 1, "", err
	}
	if len(os.Args) == 1 || isHelp(os.Args[1]) {
		return 2, usage, nil
	}
	if len(os.Args) >= 2 {
		service := os.Args[1]
		switch service {
		{{- range .Services}}
		{{- $serviceName := .Name }}
		case "{{.Name}}":
			if len(os.Args) == 2 || isHelp(os.Args[2]) {
				return 2, usageService{{camelCase $serviceName}}, nil
			}
			command := os.Args[2]
			switch command {
			{{- range .Methods}}
			case "{{dasherize .Name}}":
				output, err := do{{camelCase $serviceName}}{{.Name}}(config.Address)
				if err != nil {
					return 1, "", err
				}
				return 0, output, nil
			{{- end}}
			default:
				return 1, "", fmt.Errorf("no such command: %s", command)
			}
{{- end}}
		default:
			return 1, "", fmt.Errorf("no such service: %s", service)
		}
	}
	return 1, "", fmt.Errorf("BUG this should never happen")
}`)
)
